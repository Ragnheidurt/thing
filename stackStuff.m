%% First we generate input data
birthdate =  19980422  % Write the birth date on format yyyymmdd for oldest member in the group
format compact
[lambdavec,Tvec,cvec] = getSPOdata(birthdate)   %yyyymmdd

% -------------------------------------------------------------------------------------------------------------------
%% Marginal Allocation
% Question 1 should be answered in the report

% Question 2 should described in the report, and submitted below
%Enter on the format EBO2 = [EBO_1(2) EBO_2(2) ... EBO_9(2)]      
%EBO_j(2) should be the EBO for two spares of LRU2

EBO2 = [];
 
for i = 1:9
    EBO2_(i) = recursiveEBO(lambdavec,Tvec,2,i);
    EBO2(end+1) = EBO2_(i);
end

EBO2
Purchase_Cost = 2*sum(cvec);
EBO_Cost = "";
Cost2 = Purchase_Cost 

Q2 = [EBO2 Cost2]; % Checking both at the same time in grader.

stack1 = java.util.Stack();
stack2 = java.util.Stack();
stack3 = java.util.Stack();
stack4 = java.util.Stack();
stack5 = java.util.Stack();
stack6 = java.util.Stack();
stack7 = java.util.Stack();
stack8 = java.util.Stack();
stack9 = java.util.Stack();

stacks = [stack1, stack2, stack3, stack4, stack5, stack6, stack7, stack8, stack9];

thing = 5;
R = zeros(9,9);
for i=1:9
    for j=thing:-1:1
        pj = zeros(j,1);
        for k = j:20
           pj(k,1) = (lambdavec(i)*Tvec(i))^k/factorial(k)*exp(-lambdavec(i)*Tvec(i));
        end
        r = sum(pj);
        R(i,j) = r;
        stacks(i).push(r/cvec(i));
    end
end


stuff = [thing+1;thing+1;thing+1;thing+1;thing+1;thing+1;thing+1;thing+1;thing+1];
ebo= 0;
for i=1:9
    ebo = ebo + lambdavec(i)*Tvec(i);
end
ebo

cost = 0;
costvec = [];
%p = 0;
%pvec = [];
ebovec = [];
spareparts = zeros(9,1);
count = 1;
while cost<500
    a = 0;
    index = 0;
    for i=1:9
        if a<stacks(i).peek()
            a = stacks(i).peek();
            index = i;
        elseif a==stacks(i).peek()
            rand = Random();
            if rand < 0.5
                a = stacks(i).peek();
                index = i;
            end
        end
        if stacks(i).size() <2
            pj = zeros(stuff(i),1);
            for k = stuff(i)+1:20
                pj(k) = (lambdavec(i)*Tvec(i))^k/factorial(k)*exp(-lambdavec(i)*Tvec(i));
            end
            r = sum(pj);
            R(i,stuff(i)) = r;
            stacks(i).add(0,r/cvec(stuff(i)));
            stuff(i) = stuff(i)+1;
        end
    end
    if cost+cvec(index)<500
        %p = p+a;
        %pvec(end+1) = p;
        spareparts(index,1) = spareparts(index,1)+1;
        ebo = ebo-R(index,spareparts(index,1));
        ebovec(end+1) = ebo;
        cost = cost+cvec(index);
        costvec(end+1) = cost;
        count = count +1;
        stacks(index).pop();
    else
        break
    end
end
%pvec
ebovec
costvec
%p
ebo
cost
spareparts
%plot(costvec,-log(pvec))
plot(costvec,ebovec, '-o')

% Question 3, you should describe how the Marginal allocation is
% implemented in your own words in the report, and compute all efficient
% points.

% Question 4 should be answered in the report, with a figure and a table with
% all efficient points
% Furthermore, a table with first five efficient points should be submitted below
 
% Enter on the format EPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where xj is the row vector with number of spare parts of each kind
% corresponding to the efficient points generated by the Marginal allocation algorithm
EPtable = zeros(5,3);
for i = 1:5
    EPtable(i,:) = [i ebovec(i) costvec(i)];
end
EPtable

% Question 5 should be discussed in the report

% -------------------------------------------------------------------------------------------------------------------
%% Dynamic Programming
% Question 6 should be answered in the report

% Question 7 should be answered in the report, and submitted below

S = 50;
EBO1 = [];
Cost1 = [];
i = 1;
while S > 0
    EBO1(end+1) = recursiveEBO(lambdavec(1),Tvec(1),i,1);
    Cost1(end+1) = cvec(1)*i;
    S = S - cvec(i);
    i = i + 1;
end
EBO1
Cost1
x1 = numel(EBO1)-1;

LRU1 = [x1 EBO1(x1) Cost1(x1)]

% Question 8 should be answered in the report, and submitted below
% Enter on the format DynPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where x0 to x4 are the row vectors with number of spare parts of each kind
% corresponding to the points optimal for budgets 0,100,150, 350, 500.


% EBO = [];
% for i = 1:9
%     EBO(end+1) = recursiveEBO(lambdavec,Tvec,spareparts(i),i);
% end
% EBO
cmax = 50;

% arr= [2 4 6 8];
% summa = 10;
% ans = combinationSum(arr,summa)
EBO = inf;
EBOcosts = zeros(cmax,1);
EBOUltra = inf;
vec = [];
ultravec = [];
her = recursiveEBO(lambdavec,Tvec,1,5);
while cmax>0
    EBO = inf;
    A = combinationSum(cvec,cmax);
    for i=1:size(A,1)
        EBOnow=0;
        for j=1:9
            LRU1 = find(A(i,:)==j);
            if length(LRU1)~=0
                EBOnow = EBOnow + recursiveEBO(lambdavec,Tvec,length(LRU1),j);
            else
                EBOnow = EBOnow + recursiveEBO(lambdavec,Tvec,0,j);
            end
        end
        if EBOnow<EBO
            EBO = EBOnow;
            vec = A(i,:);
        end
    end
    EBOcosts(cmax,1) = EBO;
    if EBO<EBOUltra
        EBOUltra = EBO;
        ultravec = vec;
    end
    cmax = cmax-1;
end
actualcmax = 50;
for i=1:actualcmax
      if EBOcosts(i)>1000  && i~=1
          EBOcosts(i) = EBOcosts(i-1);
      elseif EBOcosts(i)>1000 && i == 1
          EBOcosts(i) = 0;
          for j=1:9
              EBOcosts(i) = EBOcosts(i) + recursiveEBO(lambdavec,Tvec,0,j);
          end
         % EBOcosts(i) = 10;
      end
      if i ~= 1 && EBOcosts(i)>EBOcosts(i-1)
          EBOcosts(i) = EBOcosts(i-1);
      end
end
EBOUltra
EBOcosts
ultravec

plot([1:actualcmax],EBOcosts)
% while cmax>0
%     values = find(cvec<cmax);
%     if length(values) ~= 0  
%         for i = 1:length(values)
%             
%         end
%     end
%     
% end


% DynPtable = "to do"

% Question 9 should be answered in the report

% Question 10 should be answered in the report, and submitted below
NumberOfConfigurations = 6^9

function r = recursiveEBO(lambdavec,Tvec,sj,j)
   if sj == 0
        r = lambdavec(j)*Tvec(j);
   else
       pj = zeros(9,1);
       for i=1:9
           pj(i) = (lambdavec(j)*Tvec(j))^i/factorial(i)*exp(-lambdavec(j)*Tvec(j));
       end
       r = recursiveEBO(lambdavec,Tvec,sj-1,j) - sum(pj(sj:9));       
   end
end


function [ans] = combinationSum(arr,summa)
    ans = [];
    temp = zeros(summa,1);
    arr = sort(arr);
    ans = findNumbers(ans,arr,temp,summa,1,0);
end

function [ans] = findNumbers(ans,arr,temp,summa,index,count)
    if summa == 0
        ans(end+1,:) = temp;
    end
    for i=index:length(arr)
        if summa-arr(i) >= 0
            count = count+1;
            temp(count) = i;
            findNumbers(ans,arr,temp,summa-arr(i),i,count);
            temp(count) = 0;
        end
    end
end

